# -*- coding: utf-8 -*-
"""Estructuras Recursivas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_VyXs1fEDwIYwiFfmIvwSAxG1ZyVeXjs

# Estructuras Recursivas
"""

# TAD Lista(a)
'''
Algunas operaciones de Lista(a) para tener similar a la implementacion
en pseudocodigo hecha en clase (paradigma programacion imperativa).
Tener en cuenta que no todas tienen la misma firma por una cuestion de restricciones de implementacion de python.
Nos apoyamos en la implementacion nativa de listas que viene en el lenguaje.
'''

# proced listaVacia(ref xs: Lista(a))
def listaVacia(xs):
    xs[:] = []

# proced insertar(x: a, ref xs: Lista(a))
def insertar(x, xs):
    xs.insert(0, x)

# funcion esListaVacia(xs: Lista(a)): Bool
def esListaVacia(xs):
    return not xs

# funcion head(xs: Lista(a)): a
# Como a puede ser un tipo inmutable, se implementa como funcion. Devuelve None si esta vacia.
def head(xs):
    if not esListaVacia(xs):
        return xs[0]
    else:
        return None

# funcion tail(xs: Lista(a)): Lista(a)
# Se implementa como funcion para evitar destruir la lista original ya que python no permite operar punteros.
def tail(xs):
    return xs[1:]

# proced insertarUltimo(x: a, ref xs: Lista(a))
def insertarUltimo(x, xs):
    xs.append(x)

# funcion eliminarUltimo(xs: Lista(a))
def eliminarUltimo(xs):
    return xs[:-1]

# funcion ultimo(xs: Lista(a)): a
def ultimo(xs):
  return xs[-1]

"""### Definir la función sumatoriaLista, que dada una lista de enteros, retorne la sumatoria de todos sus elementos.

```
funcion sumatoriaLista(li: Lista(Entero)): Entero
  var
    num: Entero
  
  si (not esListaVacia(li)) entonces
	  head(li, num)
    tail(li)
    devolver num + sumatoriaLista(li)
  sino
	  devolver 0
  finSi
finFuncion
```
"""

def sumatoriaLista(xs):
  if esListaVacia(xs):
    return 0
  else:
    return head(xs) + sumatoriaLista(tail(xs))

sumatoriaLista( [0,1,2,3,4,5,6] )

"""### Definir la función = (igualdad de listas) que dadas dos listas de enteros, retorne si ambas son iguales.

- contienen exactamente la misma cantidad de elementos
- poseen igualdad de elementos posición por posición)

caso base: 
  - LV y LV => Verdadero
  - LV y noLV => Falso
  - noLV y LV => Falso

caso recursivo:
  - comparar heads y sus restos


```
funcion igualdadLista(lista1, lista2: Lista(Entero): Bool
  var
    num1, num2: Entero

  si esListaVacia(lista1) entonces
    devolver esListaVacia(lista2)
  sino
    si esListaVacia(lista2) entonces
      devolver Falso
    sino
  	  head(lista1, num1)
	    head(lista2, num2)
  	  tail(lista1)
	    tail(lista2)
      devolver (num1 = num2) Y igualdadLista(lista1, lista2)
    finSi
  finSi
finFuncion
```
"""

def igualdadLista(xs, ys):
  if esListaVacia(xs):
    return esListaVacia(ys)
  else:
    if esListaVacia(ys):
      return False
    else:
      return head(xs) == head(ys) and igualdadLista(tail(xs), tail(ys))
  
igualdadLista([1,2,3], [1,2,3])

"""### Eliminar último elemento de una lista

```
proced eliminarUltimo(ref xs: Lista(a))
  vars
    aux: Lista(a)

  si not esListaVacia(xs) entonces
    aux <- xs
    tail(aux)
    si esListaVacia(aux) entonces
      # aux: NIL, xs: 1 elem
      disponer(xs)
      listaVacia(xs) # xs <- NIL
    sino
      si esListaVacia(aux^.sig) entonces
        disponer(aux)
        listaVacia(xs^.sig)
      sino
        eliminarUltimo(aux)
      finSi
    finSi
  finSi
finProced
```

### Definir la función reversa, que dada una lista de enteros, retorne una lista de enteros con todos sus elementos invertidos en sus posiciones.

Por ejemplo: reversa([4,5,2,9]) = [9,2,5,4].

```
TAD Lista(a) - Extensión operaciones
funcion listaVacia(): Lista(a)

funcion reversa(li: Lista(Entero)): Lista(Entero)
  var
    num: Entero
    liReversa: Lista(Entero)

  si (esListaVacia(li)) entonces
	  devolver listaVacia()
  sino
	  head(li, num)
	  tail(li)
    liReversa <- reversa(li)
	  insertarUltimo(num, liReversa)
    devolver liReversa
  finSi
finFuncion
```
"""

def reversa(xs):
  if esListaVacia(xs):
    return []
  else:
    liReversa = reversa(tail(xs))
    insertarUltimo(head(xs), liReversa)
    return liReversa

reversa([1,2,3,4,5])

"""```
proced reversa2(xs: Lista(Entero), ref retorno: Lista(Entero))
  listaVacia(retorno)
  reversa2_(xs, retorno)
finProced
proced reversa2_(xs: Lista(Entero), ref retorno: Lista(Entero))
  vars
    x: Entero
  si not esListaVacia(xs) entonces
    head(xs, x)
    tail(xs)
    insertar(x, retorno)
    reversa2_(xs, retorno)
  finSi
finProced
```
"""

def reversa2(xs):
  return reversa2_(xs, [])
def reversa2_(xs, retorno):
  if esListaVacia(xs):
    return retorno
  else:
    insertar(head(xs), retorno)
    return reversa2_(tail(xs), retorno)

reversa2([1,2,3,4])

"""### Reversa de una Lista con recursión de cola
```
procedimiento reversa(li: Lista(Entero), ref liReversa: Lista(Entero))
  listaVacia(liReversa)
  si(NO esListaVacia(li))entonces  
	  reversa2(li, liReversa)
  finSi
finProcedimiento

procedimiento reversa2(li: Lista(Entero), ref liReversa: Lista(Entero))
  vars
    num: Entero
    
  si (NO esListaVacia(li)) entonces
	  head(li, num)
	  tail(li)
    insertar(num, liReversa)
	  reversa2(li, liReversa)
  finSi
finProcedimiento
```

### Definir la función esPalindromo, que dada una lista de enteros, retorne si es o no es palíndromo, utilizando recursividad explícita.

```
funcion ultimo(xs: Lista(a)): a
funcion sacarultimo(xs: Lista(a)): Lista(a)

funcion palindromo(xs: Lista(Entero)): Bool

  si longitud(xs) < 2 entonces
	  devolver Verdadero
  entonces
	  si (head(xs) = ultimo(xs)) entonces
		  devolver palindromo( sacarultimo(tail(xs)) )
	  sino
		  devolver Falso
	  fsi
  fsi

finfuncion
```
"""

def palindromo(xs):
  if len(xs) < 2:
    return True
  else:
    return (head(xs) == ultimo(xs)) and palindromo(eliminarUltimo(tail(xs)))

palindromo([1,2,3,2,1])

def palindromo2(xs):
  return igualdadLista(xs, reversa(xs))

palindromo2([1,2,1])

def palindromo3(xs):
  return palindromo3_(xs, [], xs)
def palindromo3_(xs, reversa, orig):
  if esListaVacia(xs):
    return igualdadLista(reversa, orig)
  else:
    insertar(head(xs), reversa)
    return palindromo3_(tail(xs), reversa, orig)

palindromo3([1,3,3,1])

"""### Definir la función sublista, que dada una lista de enteros, un número que represente una posición y otro número que represente una longitud, devuelva una lista de enteros (que se basa en la lista dada) que comience en la posición dada y que tenga la longitud dada desde esa posición.

### Concatenar 2 listas.

```
Version 1:
proced concat(xs: Lista(Entero), ref ys: Lista(Entero))
  var
    num: Entero
    zs: Lista(a)

  reversa(xs, zs)
  si (NO esListaVacia(zs)) entonces
	  head(zs, num)
	  tail(zs)
	  concat2(zs, ys, num)
  finSi
finProced

proced concat2(xs: Lista(Entero), ref ys: Lista(Entero), num: Entero)
  insertar(num, ys)
  si(NO esListaVacia(xs)entonces
	  head(xs, num)
	  tail(xs)
	  concat2(xs, ys, num)
  finSi
finProced
```

```
Version 2: iterativa
funcion concat(xs: Lista(a), ys: Lista(a)): Lista(a)
  var
    x: a
    zs: Lista(a)

  copiarLista(xs, zs)    # no es lo mismo que hacer zs <- xs
	mientras no esListaVacia(ys) hacer
		x <- head(ys)
		zs <- insertarUltimo(zs, x)
		ys <- tail(ys)
	fMientras
  devolver zs
finFuncion
```

```
Version 3: recursión cola
funcion concat(xs: Lista(a), ys: Lista(a)): Lista(a)
  var
    x: a
  si esListaVacia(ys) entonces
    devolver xs
  sino
		x <- head(ys)
    ys <- tail(ys)
		xs <- insertarUltimo(xs, x)
    devolver concat(xs, ys)
	finSi
finFuncion

Version 3': recursión cola
proced concat(ref xs: Lista(a), ys: Lista(a))
  var
    x: a
  si not esListaVacia(ys) entonces
		x <- head(ys)
		xs <- insertarUltimo(xs, x)
		ys <- tail(ys)
    concat(xs, ys)
	finSi
finProced
```

### Intercalar Listas
[1,2,3], [4,5,6] => [1,4,2,5,3,6]

Caso base:
  - xs es LV => ys
  - ys es LV => xs

Caso recursivo op1:
  intercalar resto de xs con ys
  insertar cabeza xs en lo intercalado

Caso recursivo op2:
  intercalar resto de ys con xs
  insertar cabeza ys en lo intercalado


```
func intercalar (xs: Lista(Enteros), ys: Lista(Enteros)): Lista(Enteros)
	vars:
		liS: Lista(Enteros)
		x: Enteros
	si esListaVacia (xs) entonces: 
		devolver ys
	sino
		si  esListaVacia (ys) entonces:
			devolver xs
		sino
			head (xs, x)
			liS ← alternativa (tail(xs), ys)
			insertar (liS, x)
			devolver liS
		fSi
	fSi
fFunc

func alternativa (xs: Lista(Enteros), ys: Lista(Enteros)): Lista(Enteros)
	vars:
		liS: Lista(Enteros)
		x: Enteros
	si esListaVacia (xs) entonces: 
		devolver ys
	sino
		si esListaVacia (ys) entonces:
			devolver xs
		sino
			head (ys, x)
			liS ← intercalar (xs, tail(ys))
			insertar (liS, x)
			devolver liS
		fSi
	fSi
fFunc
```

```
proced intercar(xs: Lista(Enteros), ys: Lista(Enteros), ref zs: Lista(a))
    vars
        x: Enteros

    si esListaVacia(xs) and esListaVacia(ys) entonces: 
        listaVacia(zs)
    sino
        si esListaVacia(xs) entonces
          intercalar(ys, xs, zs)
        sino
          head(xs, x)
          tail(xs)
          intercalar(ys, xs, zs)
          insertar(zs, x)
        finSi
    fSi
finProced
```

## Permutar (versión con intercalado)

```
proced permutar(xs: Lista(a), ref xss: Lista(Lista(a)))
  vars
    x: a
    ys: Lista(a)

  si esListaVacia(xs) entonces
    listaVacia(ys)
    listaVacia(xss)
    insertar(ys, xss)
  sino
    head(xs, x)
    tail(xs)
    permutar(xs, xss)    # en xss queda el permutar del resto
    intercalarEnListas(x, xss)
  finSi
finProced

proced intercalarEnListas(x: a, xss, ref zss: Lista(Lista(a)))
  vars
    xs: Lista(a)
    yss: Lista(Lista(a))

  si esListaVacia(xss) entonces
    listaVacia(zss)
  sino
    head(xss, xs)
    tail(xss)
    intercalarEnListas(x, xss, zss)   # intercala x en el resto de xss
    intercalarX(x, xs, yss)
    concat(yss, zss)
    destruirLista(yss)
  finSi
finProced

proced intercalarX(x: a, xs: Lista(a), ref xss: Lista(Lista(a)))
  vars
    ys: Lista(a)
    y: a

  si esListaVacia(xs) entonces
    listaVacia(xss)
    listaVacia(ys)
    insertar(x, ys)
    insertar(ys, xss)
  sino
    copiarLista(xs, ys)
    head(ys, y)
    tail(xs)
    intercalarX(x, xs, xss)
    insertarListas(y, xss)
    insertar(x, ys)
    insertar(ys, xss)
  finSi
finProced
```
"""