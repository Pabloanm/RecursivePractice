# -*- coding: utf-8 -*-
"""Intro Recursion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1k37FSRmZFCIenUuBBVz-JJdOU5h4apoq

# Intro Recursión

## Definir una función recursiva producto que, dados dos números enteros z y v, retorne z*v mediante sumas sucesivas.
"""



"""Resolución:

```funcion producto(z: Entero, v: Entero): Entero

  si (v > 1) entonces
	  devolver ← producto(z, v-1) + z
  sino
	  si(v = 0)entonces
		  devolver ← 0
	  sino
		  devolver ← z
	  finSi
  finSi

finFuncion
```
---

```
funcion producto(z: Entero, v: Entero): Entero

  si (v > 0) entonces
	  devolver ← producto(z, v-1) + z
  sino
		devolver ← 0
  finSi

finFuncion
```
"""

def producto(z, v):
  if v > 0:
    return producto(z, v -1) + z
  else:
    return 0

producto(4,3)

"""## Definir una función recursiva decimalBinario que, dado un número decimal, retorne el mismo en base binaria.

Resolución:
```
funcion dec2bin(x: Entero): Entero
  si (x // 2) = 0 entonces
    devolver x RESTO 2
  sino
    devolver dec2bin(x // 2) * 10 + x RESTO 2
  finSi
finFuncion
```
"""

def dec2bin(x):
  if x // 2 == 0:
    return x % 2
  else:
    return dec2bin(x // 2) * 10 + x % 2

dec2bin(256)

"""## Definir funciones recursivas cociente y resto que, a partir de dos números enteros, retorne el cociente y el resto entre ellos respectivamente, a partir de la técnica de restas sucesivas. 
Expresar cuál sería el orden bien fundado entre los elementos del dominio para esta función.

```
funcion cociente(dividendo: Entero, divisor: Entero): Entero
  si (dividendo >= divisor) entonces
	  devolver division(dividendo - divisor, divisor) + 1
  sino
    devolver 0
  finSi
finFunc

funcion resto(dividendo: Entero, divisor: Entero): Entero
  si (dividendo >= divisor) entonces
	  devolver division(dividendo - divisor, divisor)
  sino
    devolver dividendo
  finSi
finFunc
                            coc     resto
funcion coeresto(x, y): Par(Entero, Entero)
  x:6
  y:2
  vars
    p: Par(Entero, Entero)
    i1, i2: Entero
      
      1 < 2
  si (x < y) entonces
    crearPar(0, x, p)
  sino
                  7 - 2, 2
                  5 - 2, 2
                  3 - 2, 2
                   
    p <- coeresto(x - y, y)
    primero(p, i1)
    segundo(p, i2)
    crearPar(1 + i1, i2, p)
  finSi
  devolver p
finFuncion

--- Version TAD Par con funciones

funcion coeresto(x, y): Par(Entero, Entero)
  vars
    p: Par(Entero, Entero)

  si (x < y) entonces
    crearPar(0, x, p)
  sino
    p <- coeresto(x -y, y)
    crearPar(1 + primero(p), segundo(p), p)
  finSi
  devolver p
finFuncion


--- Version destruyendo pares intermedios

funcion coeresto(x, y): Par(Entero, Entero)
  vars
    p_anterior, p: Par(Entero, Entero)

  si (x < y) entonces
    crearPar(0, x, p)
  sino
    p_anterior <- coeresto(x -y, y)
    crearPar(1 + primero(p_anterior), segundo(p_anterior), p)
    destruirPar(p_anterior)
  finSi
  devolver p
finFuncion
```
"""

# Ops de TAD Par
def primero(p):
  return p[0]
def segundo(p):
  return p[1]

def coeresto (x,y):
  if x < y:
	  return (0, x)
  else:
    resultado_previo = coeresto(x-y, y)
    cociente = 1 + primero(resultado_previo)
    resto = segundo(resultado_previo)
    return (cociente, resto)

coeresto(13, 3)

"""## Definir una función recursiva digitos, que dado un número entero, retorne su cantidad de dígitos.

```
funcion digitos(val z: Entero): Entero
	si (z > 9) entonces
		digitos <- cantEnt(z div 10) + 1
	sino
		digitos <- 1
	fSi
finFuncion
```
"""

def digitos(x):
  if x == 0:
    return 0
  if x > 0:
    return digitos (x // 10) + 1
  else:
    return digitos (x // -10) + 1


digitos(-11)

"""## Definir una función recursiva reversaNum que, dado un número entero, retorne su imagen especular. Por ejemplo: reversaNum(345) = 543

Resolución:
```
funcion potencia(numero, exponente): Entero
  si (exponente > 0) entonces
	  devolver producto(potencia(numero, exponente - 1), numero)
  sino
	  devolver 1
  finSi
finFuncion

funcion reverso(x: Entero): Entero
  si (x < 10) entonces
    devolver x
  sino
    devolver potencia(10, digitos(x) - 1) * (x resto 10) + reverso(x div 10)
finFunc
```
"""

def reverso(x):
  if x < 10:
    return x
  else:
    return pow(10, digitos(x) - 1) * (x % 10) + reverso(x // 10)

reverso(12345)

"""## Definir el procedimiento pares, que dado un número entero, muestre todos los pares de números enteros positivos que son suma del número entero dado. Por ejemplo, 5 = (1 , 4), (2, 3)

```
TAD Lista(a)
proced listaVacia(ref xs: Lista(a))
proced insertar(x: a, ref xs: Lista(a))
proced head(xs: Lista(a), ref x: a)
funcion head(xs: Lista(a)): a
proced tail(ref xs: Lista(a))

TAD Par(a,b)
proced crearPar(x: a, y: b, ref p: Par(a,b))
funcion primero(p: Par(a,b)): a
funcion segundo(p: Par(a,b)): b

funcion pares(x: Entero): Lista(Par(Entero, Entero))
  devolver pares2(x, 0)
finFuncion

funcion pares2(x, i: Entero): Lista(Par(Entero, Entero))
  vars
    p: Par(Entero, Entero)
    xs: Lista(Par(Entero,Entero))

  si (i > x-i) entonces        # i > x/2
    listaVacia(xs)
    devolver xs              # en python: return []
  sino
    xs <- pares2(x, i + 1)
    crearPar(i, x - i, p)
    insertar(p, xs)
    devolver xs
  finSi
finFuncion
```

```
--- Recursion de cola
proced pares(x: Entero, ref xs: Lista(Par(Entero, Entero)))
  listaVacia(xs)
  pares2(x, 0, xs)
finProced
 
proced pares2(x, i: Entero, ref xs: Lista(Par(Entero, Entero)))
  vars
    p: Par(Entero, Entero)
 
  si (i <= x-i) entonces
    crearPar(i, x - i, p)
    insertarUltimo(p, xs)
    pares2(x, i + 1, xs)
  finSi
finProced

--- Iterativo
proc paresI(x: Entero, ref xs: Lista(Par(Entero,Entero)))
  var
    p: Par(Entero, Entero)
    i: Entero

  listaVacia(xs)
	para i <- 0 hasta i <= (x-1)
		crearPar(i, x-i, p)
		insertarUltimo(p, xs)
	fpara
fproc
```
"""

def pares(x):
  xs = []
  pares2(x, 0, xs)
  return xs
def pares2(x, i, xs):
  if i <= x - i:
    xs.append((i, x - i))
    pares2(x, i + 1, xs)

pares(4)

"""```
pares2(4, 0, []) ->
  pares2(4, 1, [(0,4)]) ->
    pares2(4, 2, [(0,4), (1,3)]) ->
      pares2(4, 3, [(0,4), (1,3), (2,2)])   CASO BASE
```
"""

# Jugando con con pares y listas en Python
p = (0, 6)
xs = [(1,5)]
xs.insert(0, p)
#p
def mutarref(ys):
  ys.insert(0, (0,0))
  ys = []

mutarref(xs)
xs

"""## Dado un grupo de dos o más personas, establecer una estrategia recursiva que permita conocer **cuál es la persona más joven del grupo**.

Caso base: grupo de 2 personas => devuelve la persona menor.

Caso recursivo: devolver la persona de la cabeza si es mas joven que el resto del grupo.

```
TAD Persona
Tipo
  Persona = registro
              nombre: Cadena
              edad: Entero
            finReg
  ...
  funcion espersonamayor(persona1, persona2: Persona): Bool
    devolver persona1.edad > persona2.edad
  finFuncion
  ...


proced masjoven(ps: Lista(Persona), ref joven: Persona)
  vars
    persona1, persona2: Persona
  
  si not esListaVacia(ps) entonces
    head(ps, joven)
    tail(ps)
    si not esListaVacia(ps) entonces
      masjoven(ps, persona2)
      si espersonamayor(joven, persona2) entonces
        joven <- persona2
      finSi
    finSi
  finSi
finProced
```
"""

def f1(x):
  if x < 10:
    aux = f1(x+10)
    return f1(aux)
  else:
    return x - 5
    
print(f'f1(3): {f1(3)}')
print(f'f1(6): {f1(6)}')
print(f'f1(2): {f1(2)}')
print(f'f1(11): {f1(11)}')
print(f'f1(5): {f1(5)}')